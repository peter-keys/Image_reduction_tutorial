;+
;NAME: 
;	ROSA_pre_speckle_prep.pro
;  
; CATEGORY:
;   File I/O
;  	
;PURPOSE:
;	To prepare raw ROSA data for speckle interferometry (KISIP)
;	   - Sets up the required directory structures
;	   - Applies dark corrections
;	   - Applies flat-field corrections
;	   - Outputs average flat & dark for future use
;	   - Prepares average specklegram
;	   - Saves important metadata from Raw files
;	   - (Saves average target grid and dot images for future use...)  
;
;CALLING SEQUENCE:
;
;
;INPUTS:
;
;INTERACTIVE INPUTS DURING EXECUTION:
;
;
;
;KEYWORDS:
;
;OUTPUTS:
;
;
;EXAMPLES:
;
;CALLS:
;
;HISTORY:
;	ROSA reduction pipeline originally created by David B. Jess 2008
;	Modifications made by Kevin Reardon 2013
;	SOLARNET compliant pipeline generated by Peter H. Keys 2016
;	This version is a rough and ready automated version
;	I had originally planned on coming up with a program that you 
;	just run and it prompts for input every now and then. Tricky though	 
;-


;=========================================================================================================================
;			GENERATE THE NECESSARY DIRCTORY STRUCTURES
;
;	     REQUIREMENTS:
;		  - Split as days, targets & filter e.g. 27Jun2009/AR11023/Gband/
;		  - Have to have a raw folder for pre-processed data
;		  - Have to have a folder for speckled data
;		  - Speckled data split as speckled, mid_processed, processed
;		  - speckled = have been run through KISIP and are speckled (nothing more)
;		  - mid_processed = have been speckled, images aligned, and destretched
;		  - processed = fully processed, i.e., final alignments to other cameras applied to destretched images
;
;	** Make sure you have adequate permissions to create the directory structures & enough space to process **
;
;			** Be careful in naming directories so you don't overwrite previous work **
;=========================================================================================================================

	; Edit and run this file from IDL to create the necessary directory structures for your data
@ROSA_directory_generator.bat

	; Note that on completing processing, at QUB we move processed data to a separate area of the cluster (solarstore1)

;=========================================================================================================================
;					GENERATE DARK AND FLAT FILES (1k x 1k Cameras)
;
;	     REQUIREMENTS:
;		  - These are the setps for the older 1004 x 1002 Andor cameras (generally continuum filters)
;		  - You should be in the directory with the raw data taken from the ROSA system (i.e. .fit files)
;		  - If not you need to change the directory structures when doing the FILE_SEARCH
;		  - This assumes that you have already made your directory structures above
;		  - This is required as you will save out the average flat and dark file
;		  - You need to add in here some file paths for storing pre-processed and processed data
;		  - This ensures that the specklegrams and average darks/flats are stored
;		  - You also need to add the name (or comment out) the filter you are currently processing
;		  - This ensures that the average flat/darks for this filter are in the right place
;		  - A random header for frame rate is saved with the average dark/flat for general info.
;=========================================================================================================================

	; Input the raw directory and filter you are processing to saving things out
data_dir = '/data/solarstore2/ROSA_raw_files/14Oct2016/raw/'							; Directory of raw data from the telescope
raw_dir = '/data/solarstore2/ROSA_raw_files/14Oct2016/prespeckle/Long/'					; Directory of raw specklegrams (pre-speckled raw data)
reduced_dir = '/data/solarstore2/ROSA_raw_files/14Oct2016/processing/Long/'					; Directory of processed images (post-speckle data)

	; Comment out filters not currently being processed 
;filter = 'Gband'
;filter = 'Continuum4170'
;filter = 'Continuum3500'
;filter = 'CaK'
filter = 'Hbeta'

	; Input the image dimensions of the camera you are processing
;imagedim = [1004,1002]
imagedim = [512,512]

	; Pointing information for later - manually input it
	;	x = E/W with W +VE
	;	y = N/S with N +VE
	;
	;	e.g N5.8,E3.2 = [(-3.2),5.8]
pointing = [67.6,(-16.3)]	;10th 1st = [14.5,(-15.4)] 2nd = [15.0,(-15.4)]
;12Oct2016 0.3,3.1 1st

	;Check the directory you are currently in:
$pwd
print,' '
print,'If you are not in the directory where your data is stored (e.g. DAS1_27Jun2009/*.fit) please change it now'
print,'You should see a lot of .fit, files as that is how data is stored form the ROSA system...'
print,' '
;=========================================================================================================================
;					GENERATE AVERAGE FLAT/DARK (1k x 1k Cameras)
;
;	     REQUIREMENTS:
;		  - You will generate the average dark/flat here
;		  - This will be saved out to the calibration directroy of you data path for future use
;		  - Be careful in choosing the right dark/flat for a given exposure time
;		  - Your flat/dark must be separate if you have multiple exposures in one day
;=========================================================================================================================
;---------------------------------------------------------------------------------------
; ** Make the average dark file  (1004 x 1002 Cameras - i.e. Gband/Continuum) **
;---------------------------------------------------------------------------------------

files = FILE_SEARCH('*darks*')
;files = FILE_SEARCH('/data/rosa4/ROSA_raw_files/12Oct2016/DAS1_12Oct2016_Fischer/das1_rosa_darks_2016-10-12_19.33.40_*.fit')
IF N_ELEMENTS(files) gt 14 THEN files = files[0:14]

image = FLTARR(1004,1002)
ave_dark = FLTARR(1004,1002,((N_ELEMENTS(files)-1)*256),/nozero)
counts = FLTARR(N_ELEMENTS(ave_dark[0,0,*]))
FOR d = 0,((N_ELEMENTS(ave_dark[0,0,*])/256.)-1) DO BEGIN &$
    FOR i = 0,255 DO ave_dark[*,*,i+(d*256)] = READFITS(files[d],exten=(i+1),/silent) &$
ENDFOR

FOR i = 0,(N_ELEMENTS(counts)-1) DO counts[i] = (TOTAL(TOTAL(REFORM(ave_dark[*,*,i]),2),1) / (1004.*1002.))

	;Plot out the average dark pixel count for each frame to make sure it is fairly steady (and as expected)
	;Expect around 200 - 350 counts in the 1k x 1k Camera darks

plot,counts,xtitle='Frame',ytitle='Average Pixel Count',charsize=2,yst=1,xst=1
ave_dark = REBIN(FLOAT(ave_dark),1004,1002,1)

;---------------------------------------------------------------------------------------
; ** Make the average Flat file  (1004 x 1002 Cameras - i.e. Gband/Continuum) **
;---------------------------------------------------------------------------------------

files = FILE_SEARCH('*flat*')
;files = FILE_SEARCH('/data/rosa4/ROSA_raw_files/12Oct2016/DAS1_12Oct2016_Fischer/das1_rosa_flats_2016-10-12_20.15.20_*')
IF N_ELEMENTS(files) gt 14 THEN files = files[0:14]

image = FLTARR(1004,1002)
ave_flat = FLTARR(1004,1002,((N_ELEMENTS(files)-1)*256),/nozero)
counts = FLTARR(N_ELEMENTS(ave_flat[0,0,*]))
FOR d = 0,((N_ELEMENTS(ave_flat[0,0,*])/256.)-1) DO BEGIN &$
    FOR i = 0,255 DO ave_flat[*,*,i+(d*256)] = FLOAT(READFITS(files[d],exten=(i+1),/silent)) &$        
ENDFOR
	;As before plot out the average counts for the flats to check they are steady and as expected
	;Expect values between 4000 - 6500 for 1k x 1k cameras to remain linear
	
FOR i = 0,(N_ELEMENTS(counts)-1) DO counts[i] = (TOTAL(TOTAL(REFORM(ave_flat[*,*,i]),2),1) / (1004.*1002.))
plot,counts,xtitle='Frame',ytitle='Average Pixel Count',charsize=2,yst=1,xst=1
ave_flat = REBIN(FLOAT(ave_flat),1004,1002,1)
ave_flat = ave_flat - ave_dark
ave_flat = ave_flat / MEDIAN(ave_flat)

	;Check Flat to see that it looks okay visually
	;This is median corrected so peak should be about 1.3 (more if there is a flare)
tvim,ave_flat,/sc 	

	; Take a random header file for the frame rate information
	
f = READFITS(files[6],exten=100,h,/SILENT)	
frame_rate_header = h[11]

	; Save out the Average Dark/Flat in case it is needed in the future...

;SAVE,FILENAME=reduced_dir+'/'+filter+'/calib/'+'Average_dark_flat_'+filter+'.sav',ave_dark,ave_flat,frame_rate_header
SAVE,FILENAME=reduced_dir+filter+'/calib/'+'Average_dark_flat_'+filter+'.sav',ave_dark,ave_flat,frame_rate_header

;=========================================================================================================================
;					GENERATE SPECKLEGRAMS (1k x 1k Cameras)
;
;	     REQUIREMENTS:
;		  - You need to have generated the average dark/flat
;		  - You need to have the 'Raw' directory structures present to save the specklegrams to
;		  - Raw in this sense is the pre-speckled 'Raw' data (i.e. dark/flat subtracted raw data)
;		  - These need to have the 'filter' and 'target' sub-directories as well
;		  - This is where you will select the cadence of your reduced data
;		  - This is decided by the frame rate and the number of images used in a specklegram
;		  - For ease of operation keep as a factor of 256 for 1kx1k cameras (i.e. 32, 64...)
;		  - Can't have too small a value or specklegram/reduced data suffers (16 is pushing it)
;		  - In general, the worse the average seeing the larger the specklegram number needs to be
;
;	** Be careful in choosing the right data files as there may be multiple pointings for a given day **	
;=========================================================================================================================

;*********************************************************************************
;			A NOTE ON TIMING INFORMATION
;
;		Best to discuss this before this section...
;	One of the most frequent questions I am asked is on timing 
;	information from ROSA data. With ROSA, all cameras are synchronised
;	initially using a trigger box when you start observing. The cameras 
;	then run off the frame rate that they have set based on the exposure 
;	time of the camera. They are then triggered again when a new file is 
;	opened. For the 1k x 1k cameras, the name of the file has the initial
;	time (in UT) when the observer has started to observe. This is in the 
;	header of the first raw image. Each subsequent file opened by the ROSA 
;	system until observations are stopped have the same time on the file
;	name. Now, with the external windows machines (i.e. the 512 x 512 
;	cameras) a similar process happens. However, the time stamp that it  
;	uses is the time when the observer hits the 'take signal' button. The 
;	camera then waits for the trigger from the sync box. Therefore, the 
;	time stamps on the old ROSA cameras and the newer 512 x 512 cameras 
;	are always going to be a few seconds off. On some occasions, they can 
;	be several minutes off  if, say, the observer goes off and makes a 
;	cup of tea while waiting for the seeing to improve. ** Therefore, it 
;	is imperative that you use the 1k x 1k continuum channels for your 
;	timing information ** Remember that the intial frame across all 
;	channels will be the same time. In the past we have always used the 
;	cadence and the initial start time to work out accurate times for a 
;	specific frame. I will try in this iteration of the ROSA pipeline to  
;	add the time information into the header of the reduced data. (In the 
;	past this was difficult as the header is lost when piping the data 
;	into KISIP). Whether or not I am successful in this remains to be 
;	seen. It is expected that with SOLARNET this should be included 
;	in the meta data, but that is not guaranteed in this version of the
;	pipeline. (P. Keys Nov 2016).
;
;*********************************************************************************

	; Read in your raw ROSA data files taken from the rosa system and on your HDDs
	; Be careful here to get your correct pointing as multiple pointings may be present for a given day
	
files = FILE_SEARCH('/data/solarstore2/ROSA_raw_files/10Oct2016/raw/DAS2_10Oct2016_Long/first_pointing/das2_rosa_2016-10-10_18.13.14_*')
save_directory = raw_dir+filter+'/

	; burst_number is the number of images you want to use for your average specklegram
	; For these cameras we want an integer number of 256 (i.e. 16, 32, 64...)
	; THIS GOVERNS YOUR REDUCED CADENCE AND POTENTIAL DATA QUALITY
	
burst_number = 64.
factor = 256. / burst_number
image = FLTARR(1004,1002)
datacube = FLTARR(1004,1002,burst_number,/nozero)

	; Change the frame rate here to get the reduced cadence (in secs)
	;tot_im_num is the total number of images you'll get at this burst_number
cadence = burst_number / (30.3/2.)	;FPS  
tot_im_number = (N_ELEMENTS(files)-1)*factor
print,' '
print,'Number of reduced images at '+arr2str(cadence,/trim)+'s is '+arr2str(tot_im_number,/trim) +' ('+arr2str(tot_im_number*cadence/60.,/trim)+'mins)'
print,' '

batch = 0
counter = 0
FOR i = 0,(N_ELEMENTS(files)-2) DO BEGIN &$
    FOR j = 0,(factor-1) DO BEGIN &$
        first_element = burst_number * j &$
        last_element = (burst_number * j) + (burst_number - 1) &$
        datacube[*] = 0. &$
        FOR k = (first_element + 1.),(last_element+1) DO BEGIN &$
            image = READFITS(files[i],exten=k,/silent) &$
	    image = (FLOAT(image) - ave_dark) / ave_flat &$
            datacube[*,*,(k-(first_element+1))] = image &$
        ENDFOR &$
	datacube = datacube>0. &$
	IF (batch le 9) THEN batchname = '0' + arr2str(batch,/trim) &$
	IF (batch gt 9) AND (batch le 99) THEN batchname = arr2str(batch,/trim) &$
	IF (counter le 9) THEN name = '0000' + arr2str(counter,/trim) &$
        IF (counter gt 9) AND (counter le 99) THEN name = '000' + arr2str(counter,/trim) &$
        IF (counter gt 99) AND (counter le 999) THEN name = '00' + arr2str(counter,/trim) &$
        IF (counter gt 999) AND (counter le 9999) THEN name = '0' + arr2str(counter,/trim) &$
        IF (counter gt 9999) AND (counter le 99999) THEN name = '' + arr2str(counter,/trim) &$
	OPENW,out_lun,/GET_LUN,save_directory+'kisip.raw.batch' + batchname + '.' + STRING(counter,FORMAT='(I3.3)') &$
	WRITEU,out_lun,datacube &$
	CLOSE,out_lun & FREE_LUN,out_lun &$   
	PRINT,'Processed image number '+ARR2STR(((batch*1000)+(counter+1)),/trim)+' of '+ARR2STR(((N_ELEMENTS(files)-1)*factor),/trim) &$
        counter = counter + 1 &$
	IF counter eq 1000 THEN batch = batch + 1 &$
	IF counter eq 1000 THEN counter = 0 &$
    ENDFOR &$
    tvim,datacube[*,*,0],/sc &$
ENDFOR

	; For some reason that I have yet to establish properly (possibly due to chosen observing mode
	; or the GUI not compensating for triggering) the frame rate for the 512x512 cameras can be off.
	; To get round this we can make a fairly good estimate of the frame rate by comparing the number 
	; of files that we have in the continuum (with a known frame rate) with those of the 512x512 
	; cameras. Here then, we calculate the number of raw images in the continuum cameras for later 
	; use in this calculation. This is complicated slightly as the FITS header for the older cameras 
	; does not store the 'NUMKIN' value which we use to find the number of images in a file (and in 
	; particular here the last file). What we have to do here then is to try to read in the last 
	; file of the current run of 1004x1002 camera data as images, and it will fail at some stage as 
	; it will more than likely be an incomplete file (i.e. not a full 256 images). You will then have 
	; to manually input the number that it says it fails at below as 'EOF', i.e., the 'End Of File'.
	; [You will get something like this on the screen: 
	; "% READFITS: EOF encountered attempting to read extension 223" Here we put EOF = 223 ]
	; This calculates a value for the last_number_cont which takes the number of full files, works 
	; out the number of images in these full files then adds the number of images in the last file 
	; to give you a total number of images in the continuum channel. Later you will load this value in
	; to compare with the number of images in the 512x512 camera and work out the frame rate (and 
	; therefore cadence) of the 512x512 camera you are processing.
	;
	; ** There is a massive caveat with this caluclation though. That is, this method is only applicable 
	; for certain observing modes within the GUI. One of the modes will stop the 512x512 cameras 
	; when the 1004x1002 cameras stop, which is were this method is applicable. With the other mode, 
	; the 512x512 cameras will continue to run until you hit 'stop' on their own Andor Solis GUI. In 
	; this case you can't use this method, as the end time isn't the same, and there is a possibility 
	; that a large number of additional images are taken and, thus, this calculation of the frame rate 
	; will be massively wrong. Also, with certain observing methods the 512x512 camera GUI gives the 
	; right frame rate. This method then is just a check to make sure that the GUI is telling the truth.
	; There are particular issues with the DJC_cam if you have an exposure that is far to fast for the 
	; camera to handle. This DJC_cam scenario is explained in the pipeline manual. **
	

last_file_test = FLTARR(1004,1002,256)
FOR i = 0, 255 DO last_file_test[*,*,i] = READFITS(files[(N_ELEMENTS(files)-1)],exten=i+1,last,/SILENT)

EOF = 223.		; Input the number on screen here
EOF = EOF - 2.
last_number_cont = (256. * (N_ELEMENTS(files)-1)) + EOF					; Number of points in the last file

	; Output the header from the first image for later use (primarily the time information)
	
f = READFITS(files[0],exten=1,start_header,/SILENT)
SAVE,FILENAME=raw_dir+filter+'/'+'Initial_header_info_'+filter+'.sav',start_header,last_number_cont

;=========================================================================================================================
;				HOW TO PREP THE DATA FOR THE 512 x 512 CAMERAS
;
;	     REQUIREMENTS:
;		  - This process will create average dark, flat and specklegram for the 512x512 cameras
;		  - This is usually for the CaK, Hbeta and Halpha (Zeiss when used with ROSA) cameras
;		  - I've had to keep it separate from the other method as the images are stored differently
;		  - With these cameras the raw images are stored as 4095 instead of 256 extensions
;		  - READFITS needs the keyword 'nslice' instead of 'exten' for these cameras.
;		  - Therefore, it was easier to separate these procedures from each other
;		  - Note that the headers for these cameras do not have the keyword 'frame rate'
;		  - Therefore we store the exposure time instead for the camera in the 'calib' folder
;
;	*** REMEMBER - Be careful with selecting files so that you are dealing with the right exposure and target ***	
;=========================================================================================================================
;---------------------------------------------------------------------------------------
; ** Make the average Dark file  (512 x 512 Cameras - i.e. CaK/Hbeta) **
;---------------------------------------------------------------------------------------
	; Load in files
files = FILE_SEARCH('*dark*.fits')
image = FLTARR(512,512)
; Find the number of images in the file
test = READFITS(files[N_ELEMENTS(files)-1],h,/SILENT)
eof = SXPAR(h,'NUMKIN')
num_ims = ((N_ELEMENTS(files)-1)*4095.) + EOF
delvar,test

	; Next line cuts out excessive amounts of dark files (limits to 4 full files)
IF (num_ims GT 16380.) THEN files = files[0:3] 
IF (num_ims GT 16380.) THEN EOF = 4094.
IF (num_ims GT 16380.) THEN num_ims = 16380.

ave_dark = FLTARR(512,512,num_ims,/nozero)

	; Loop for dark images. IF statements decide which loop if you have more than one full file
IF (num_ims GT 4095) THEN BEGIN &$
FOR i = 0, (N_ELEMENTS(files)-2) DO BEGIN &$
	FOR k = 0, 4094 DO BEGIN &$
	    image = READFITS(files[i],nslice=(k),/silent) &$
	    ave_dark[*,*,(i*4095.) + k] =  image &$
	ENDFOR &$
ENDFOR &$
FOR i = 0, EOF DO ave_dark[*,*,((N_ELEMENTS(files)-1)*4095.)+i] = READFITS(files[(N_ELEMENTS(files)-1)],nslice=(i),/silent) &$
ENDIF

IF (num_ims LE 4095) THEN BEGIN &$
FOR i = 0,(num_ims)-1 DO BEGIN &$
    image = READFITS(files[0],nslice=(i),/silent) &$
    ave_dark[*,*,i] =  image &$
ENDFOR &$
ENDIF

ave_dark = REBIN(FLOAT(ave_dark),512,512,1)

	; Check the dark is alright
tvim,ave_dark,/sc

;---------------------------------------------------------------------------------------
; ** Make the average Flat file  (512 x 512 Cameras - i.e. CaK/Hbeta) **
;---------------------------------------------------------------------------------------

files = FILE_SEARCH('*flat*.fits')

	; Find the number of images in the file
	; You need to load in the last file first to get header for the end of file (EOF) value
	; This may take a while to load
	; The old version looked for complete files and it was up to you whether or not 
	;   you used one file or more.
	; New version looks for the end of your last file, works out the number of images
	;   you have and uses that to generate a flat.
	; This should be a more accurate flat as you are using all images that you have as 
	;   opposed to clipping to the a given number of images

test = READFITS(files[N_ELEMENTS(files)-1],h,/SILENT)
eof = SXPAR(h,'NUMKIN')
num_ims = ((N_ELEMENTS(files)-1)*4095.) + EOF
delvar,test

;IF (num_ims GT 16380.) THEN files = files[0:3] 
;IF (num_ims GT 16380.) THEN EOF = 4094.
;IF (num_ims GT 16380.) THEN num_ims = 16380.

image = FLTARR(512,512)
ave_flat = FLTARR(512,512,num_ims,/nozero)

FOR d = 0, (N_ELEMENTS(files)-1) DO BEGIN &$
 ;FOR d = 0,((N_ELEMENTS(ave_flat[0,0,*])/4095.)-1) DO BEGIN &$
 IF (d LT (N_ELEMENTS(files)-1)) THEN BEGIN &$
     FOR i = 0,4094 DO ave_flat[*,*,(d*4095)+i] = READFITS(files[d],nslice=(i),/silent) &$
 ENDIF ELSE BEGIN &$
 ;IF (d LT (N_ELEMENTS(files)-1)) THEN BEGIN &$
     FOR i = 0, EOF-1 DO ave_flat[*,*,(d*4095)+i] = READFITS(files[d],nslice=(i),/silent) &$
 ;ENDIF &$
 ENDELSE &$
ENDFOR

ave_flat = REBIN(FLOAT(ave_flat),512,512,1)
ave_flat = ave_flat - ave_dark
ave_flat = ave_flat / MEDIAN(ave_flat)
tvim,ave_flat,/sc

f = READFITS(files[0],nslice=100,h,/SILENT)	
exposure_header = h[25]


;---------------------------------------------------------------------------------------
; ** Make the specklegrams  (512 x 512 Cameras - i.e. CaK/Hbeta) **
;---------------------------------------------------------------------------------------

files = FILE_SEARCH('DJCcam_data_15.33.30._*.fits')
save_directory = raw_dir+filter+'/'

; THERE ARE 4095 H-ALPHA IMAGES PER FILE SO TRY AND KEEP THE burst_number AN INTEGER FACTOR OF 4095!!!!
; FACTORS TO CHOOSE FROM INCLUDE 21, 35, 39, 45, 63, 65, 91
burst_number = 35.   
factor = 4095. / burst_number 
image = FLTARR(512,512)
datacube = FLTARR(512,512,burst_number)

; AS THE FILES CONTAIN SO MANY IMAGES, WE NEED A REMAINDER FOR THE FINAL FILE. THIS COULD BE 
; AUTOMATED, BUT I'M TOO LAZY SO DO IT YOURSELF!!!!!
image = READFITS(files[N_ELEMENTS(files)-1],nslice=1,h,/silent)

	; Old way left as comments as a check
;print,h[13] ; SHOULD BE "NUMKIN" WHICH IS THE SERIES LENGTH
;numkin = 97. ; ENTER NUMKIN VALUE HERE

	; Automated way
numkin = SXPAR(h,'NUMKIN')
remainder = FIX(numkin / burst_number)

;temp = FLTARR(512,512,2)

	; Create the specklegrams for the 512 x 512 images
	; The average specklgram should appear on screen with the counts
	; Counts should be in the range 1800 - 4000 (under normal circumstances)
batch = 0
counter = 0
FOR i = 0,(N_ELEMENTS(files)-2) DO BEGIN &$
    FOR j = 0,(factor-1) DO BEGIN &$
        first_element = burst_number * j &$
        last_element = (burst_number * j) + (burst_number - 1) &$
        datacube[*] = 0. &$
        FOR k = (first_element + 1.),(last_element+1) DO BEGIN &$
            image = READFITS(files[i],nslice=k-1,/silent) &$
	    image = (FLOAT(image) - ave_dark) / ave_flat &$
            datacube[*,*,(k-(first_element+1))] = image &$
        ENDFOR &$
	;temp[*,*,0] = datacube[*,*,0] &$
	;FOR k = 1,(burst_number-1) DO BEGIN &$
	;    temp[*,*,1] = datacube[*,*,i] &$
	;    FOR z = 0,4 DO ccshifts = TR_GET_DISP(temp,/shift) &$
	;    datacube[*,*,i] = temp[*,*,1] &$
	;ENDFOR &$
	IF (batch le 9) THEN batchname = '0' + arr2str(batch,/trim) &$
	IF (batch gt 9) AND (batch le 99) THEN batchname = arr2str(batch,/trim) &$
	IF (counter le 9) THEN name = '0000' + arr2str(counter,/trim) &$
        IF (counter gt 9) AND (counter le 99) THEN name = '000' + arr2str(counter,/trim) &$
        IF (counter gt 99) AND (counter le 999) THEN name = '00' + arr2str(counter,/trim) &$
        IF (counter gt 999) AND (counter le 9999) THEN name = '0' + arr2str(counter,/trim) &$
        IF (counter gt 9999) AND (counter le 99999) THEN name = '' + arr2str(counter,/trim) &$
	OPENW,out_lun,/GET_LUN,save_directory+'kisip.raw.batch' + batchname + '.' + STRING(counter,FORMAT='(I3.3)') &$
	WRITEU,out_lun,datacube &$
	CLOSE,out_lun & FREE_LUN,out_lun &$   
	PRINT,'Processed batch number '+ARR2STR(((batch*1000)+(counter+1)),/trim)+' of '+ARR2STR((((N_ELEMENTS(files)-1)*factor)+remainder),/trim) &$
        counter = counter + 1 &$
	IF counter eq 1000 THEN batch = batch + 1 &$
	IF counter eq 1000 THEN counter = 0 &$
	IF counter MOD 10 EQ 0 THEN tvim,datacube[*,*,0]>0.,/sc,/noaxis &$
	IF counter MOD 10 EQ 0 THEN wait,0.1 &$
    ENDFOR &$
ENDFOR
FOR i = (N_ELEMENTS(files)-1),(N_ELEMENTS(files)-1) DO BEGIN &$
    FOR j = 0,(remainder-1) DO BEGIN &$
        first_element = burst_number * j &$
        last_element = (burst_number * j) + (burst_number - 1) &$
        datacube[*] = 0. &$
        FOR k = (first_element + 1),(last_element + 1) DO BEGIN &$
            image = READFITS(files[i],nslice=k-1,/silent) &$
	    image = (FLOAT(image) - ave_dark) / ave_flat &$
            datacube[*,*,(k-(first_element+1))] = image &$
        ENDFOR &$
	;temp[*,*,0] = datacube[*,*,0] &$
	;FOR k = 1,(burst_number-1) DO BEGIN &$
	;    temp[*,*,1] = datacube[*,*,i] &$
	;    FOR z = 0,4 DO ccshifts = TR_GET_DISP(temp,/shift) &$
	;    datacube[*,*,i] = temp[*,*,1] &$
	;    temp[*,*,0] = datacube[*,*,i] &$
	;ENDFOR &$
	IF (batch le 9) THEN batchname = '0' + arr2str(batch,/trim) &$
	IF (batch gt 9) AND (batch le 99) THEN batchname = arr2str(batch,/trim) &$
	IF (counter le 9) THEN name = '0000' + arr2str(counter,/trim) &$
        IF (counter gt 9) AND (counter le 99) THEN name = '000' + arr2str(counter,/trim) &$
        IF (counter gt 99) AND (counter le 999) THEN name = '00' + arr2str(counter,/trim) &$
        IF (counter gt 999) AND (counter le 9999) THEN name = '0' + arr2str(counter,/trim) &$
        IF (counter gt 9999) AND (counter le 99999) THEN name = '' + arr2str(counter,/trim) &$
	OPENW,out_lun,/GET_LUN,save_directory+'kisip.raw.batch' + batchname + '.' + STRING(counter,FORMAT='(I3.3)') &$
	WRITEU,out_lun,datacube &$
	CLOSE,out_lun & FREE_LUN,out_lun &$   
	PRINT,'Processed batch number '+ARR2STR(((batch*1000)+(counter+1)),/trim)+' of '+ARR2STR((((N_ELEMENTS(files)-1)*factor)+remainder),/trim) &$
        counter = counter + 1 &$
	IF counter eq 1000 THEN batch = batch + 1 &$
	IF counter eq 1000 THEN counter = 0 &$
	IF counter MOD 10 EQ 0 THEN tvim,datacube[*,*,0]>0.,/sc,/noaxis &$
	IF counter MOD 10 EQ 0 THEN wait,0.1 &$
    ENDFOR &$
    tvim,datacube[*,*,0],/sc,/noaxis &$
ENDFOR

	; Frame rate is not stored in this header so manually input 
	; it as it is important to work out the cadence
	; First load in the number of continuum images so that 
	; you get a more accurate frame rate [see notes above in 
	; generating the 1004x1002 specklegram.] (NB. if you 
	; don't use Gband change the string below to the appropriate 
	; continuum channel in the 1004x1002 cameras. Also note that 
	; 9/10 times the frame rate will be 30.3 for the 1004x1002 cameras
	; change this value below in 'frame_rate_header = 30.3/...' 
	; if necessary, i.e., if you ran at 15.15).
	
restore,raw_dir+'/Gband/Initial_header_info_Gband.sav',/ver
last_im_num = ((N_ELEMENTS(files)-1)*4095.)+numkin
frame_rate_header = 30.3/(last_number_cont/last_im_num)		;10th 1st = 97651, 2nd = 50724 6th 1st = 93898.0 2nd = 80602.0 11th 46558/9313. 18th 86642 ;CaK 2 12th 15605 ; gband 14 141076 cak 140440/28095
cadence = burst_number / frame_rate_header

	; If needed you can work out the frame_rate from the exposure time using below
	; More accurate to write it down while obsevring and manually inputting it above though	
;exposure = SXPAR(h,'EXPOSURE')
;frame_rate_camera_head = 1 / (exposure + 0.03)

SAVE,FILENAME=reduced_dir+filter+'/calib/'+'Average_dark_flat_'+filter+'.sav',ave_dark,ave_flat,exposure_header,frame_rate_header

;=========================================================================================================================
;					NOW NEED TO CALL KISIP
;
;	     REQUIREMENTS:	
;		  - By this stage you should have generated some specklgrams from the raw data
;		  - These will have the format 'kisip.raw.batc00.000' etc...
;		  - Note that these can be loaded with 'load_speckle_im.pro'
;		  - You must have KISIP installed to speckle the data
;		  - See: www.arm.ac.uk/~cjn/speckle.manual.pdf ... for info
;		  - Below is an example of values for running speckle on the 1k x 1k cameras
;		  - Process is basically the same for 512x512 cameras, except you will need to change things
;		  - For 512x512 change the camera dimensions and the spatial sampling (0.069 - 0.138 usually)
;=========================================================================================================================

;---------------------------------------------------------------------------------------
; 				** CALLING SPECKLE **
;
;  - Example of values you should put into the KISIP GUI with the 1k x 1k
;  - You can add this directly to the files 'init_*.dat'
;  - This would be awkward though as you have to know what the values represent
;  - I would advise using the KISIP GUI
;  - This can be run with MPI for parallel processing
;  - I would also suggest running tests on these values as slight changes may be good
;---------------------------------------------------------------------------------------

; START KISIP GUI
; GOTO /home/dbj/IDL/KISIP
; TYPE ./kisip_gui
; FILE: OPTIONS:
;       SELECTED FILENAME: /data/rosa3/oldrosa1/Speckle/Data/Raw/13Jul2011/Gband/kisip.raw.batch00
;       (note: basically just leave off the final numbering of the filename)
;       START: 000
;       END: 999
;       SELECTED FILENAME: /data/rosa3/oldrosa1/Speckle/Data/Recontructed/13Jul2011/Gband/Gband_kisip_batch00
;       (note: basically the save directory minus the final numbering of the filename)
; DATA: PROPERTIES:
;       XSIZE: 1004
;       YSIZE: 1002
;       ARCSEC/PX IN X: 0.069
;       ARCSEC/PX IN Y: 0.069
;       TELESCOPE DIAMETER: 760 (in mm)
;       WAVELENGTH: 430.5 (in nm)
;       ADAPTIVE OPTICS USED: yes and tick box
;       AO LOCK STRUCTURE: auto (unless poor speckle then manually type in lock point in pixels)
; CLICK ON TRIPLE CORRELATION TAB
;       SUBFIELD SIZE: 5.0 
;       PHASE REC: 100
;       U IN X: 10
;       U, V & U+V: 10
;       MAXIMUM ITERATIONS: 60
;       AUTOSET THRESHOLD: 95
;       WEIGHTING EXPONENT: 1.2
;       PHASE APODISATION: 15
;       TICK NOISE-FILTERING BOXES
; CLICK ON WRITE
; CLICK ON QUIT
;
;;;OLD;;; OPEN hostfile
;;;OLD;;;     LIST NODES AND CORES USED (eg r22:8)
;;;OLD;;; 
;;;OLD;;; SUBMIT PARALLEL JOB USING:
;;;OLD;;; nohup mpirun -machinefile /home/dbj/IDL/KISIP/hostfile -n 8 /home/dbj/IDL/KISIP/entry < /dev/null > log.txt &
;;;OLD;;; NOTE: the "8" above is the TOTAL number of cores listed in hostfile
;
;;;OLD;;;     SSH INTO wasp
;;;OLD;;;     GOTO /home/dbj/IDL/KISIP
;
;;;OLD;;;     START THE JOB USING:
;;;OLD;;;     qsub sg3_kisip.run
;;;OLD;;;
;;;OLD;;;     CHECK THE JOB STATUS BY TYPING:
;;;OLD;;;     qstat -l
;
;
; THIS INDICATES HOW TO RUN IT USING THE ARC MPI QUEUE MANAGER (SLURM)
;	(may be different in other institutes... see KISIP manual)
;	   Slurm Workload Manager: https://slurm.schedmd.com
;
;
; SSH INTO starbase
; GOTO /home/phk/idl/KISIP_sg3
;
; AFTER RUNNING THE ./kisip_gui PROGRAM:
; START THE JOB USING:
; salloc -p sg3 -n 48 -J speckle_phk ./slurm_kisip_sg3.tcsh &
; OR FOR SG2:
; salloc -p sg2 -n 88 -J speckle_phk ./slurm_kisip_sg2.tcsh &
; OR FOR SG4:
; salloc -p sg4 -n 48 -J speckle_phk ./slurm_kisip_sg4.tcsh &
; 
; TO VIEW THE JOBS LIST TYPE:
; squeue
;
; TO SEE AN INTERACTIVE VIEW TYPE:
; sview

;*************************************************************************************************************************
; 		YOU ARE NOW FINISHED PRE-PROCESSING.
;
;		Data is now completely speckled, you must now pass on to post-speckle processing
;		These steps include: 
;			+ Convert images back to .fits format
;			+ Perform rigid alignment between frames for a single camera
;			+ Destretch the images 
;			+ A final small scale rigid alignment between frames for one camera
;			+ Work out the rotation, scale etc. to align different cameras
;			+ Apply these values so all cameras are aligned with respect to one another
; 
;		From here on out the processes are the same for the 512 x 512 and 1k x 1k cameras
;		We just need to be careful with array dimensions when treating these data sets
;*************************************************************************************************************************

;=========================================================================================================================
;					CONVERT DATA BACK TO .FITS FORMAT
;
;	     REQUIREMENTS:	
;		  - You need to have speckled the data by this stage
;		  - This stage simply converts the speckled files back to fits format
;		  - Uses the program 'load_speckle_im.pro' to convert
;=========================================================================================================================

	; Load in the images and set the final directory for the .fits files to be written to
kisip_directory = reduced_dir+filter+'/speckled/'
final_directory = reduced_dir+filter+'/speckled/'+filter+'_'
files_kisip = FILE_SEARCH(kisip_directory+'*.final')

	; May crash here if you do not have the correct image dimensions for your camera set previously
image_size = imagedim

counter = 0
FOR i = 0,(N_ELEMENTS(files_kisip)-1) DO BEGIN &$
    image = LOAD_SPECKLE_IM(files_kisip[i],imsize=image_size)>0. &$
    ;image_new = ROTATE(image,3) &$
    image_new = image &$
    IF (counter le 9) THEN name = '0000' + arr2str(counter,/trim) &$
    IF (counter gt 9) AND (counter le 99) THEN name = '000' + arr2str(counter,/trim) &$
    IF (counter gt 99) AND (counter le 999) THEN name = '00' + arr2str(counter,/trim) &$
    IF (counter gt 999) AND (counter le 9999) THEN name = '0' + arr2str(counter,/trim) &$
    IF (counter gt 9999) AND (counter le 99999) THEN name = '' + arr2str(counter,/trim) &$
    WRITEFITS,final_directory+name+'.fits',image_new &$
    IF i MOD 100 eq 0 THEN print,'Processing image '+arr2str(counter+1,/trim)+' of '+arr2str(N_ELEMENTS(files_kisip),/trim) &$
    counter = counter + 1 &$
ENDFOR

;=========================================================================================================================
;					RIGIDLY ALIGN THE DATA
;
;	     REQUIREMENTS:	
;		  - You need to have converted the speckled files to the .fits format
;		  - This aligns the images between frames in a data set.
;		  - This is necessary prior to destretching the data
;		  - This is a tricky(ish) step, in that there are 3 methods of doing it:
;			+ Cumulative alignment
;			+ Semi-cumulative alignment
;			+ Frame-by-frame alignment
;		  - It is a little bit trial and error though frame-by-frame works for the bulk
;		  - Only an issue if it's QS (where there will be more shifts) or poor seeing
;		  - Visually check that the alignment is decent at the end before moving on
;		  - It is also possible in extreme cases to pick a high contrast source and use that to align
;		  - I wouldn't really use that method, though it is included here 
;		  - You will need to comment things in/out (i.e. x1,x2,y1,y2) if you're using this approach
;		  - User visually tests the alignment at the end to see that is okay before proceeding further
;		  - This test requires 'XSTEPPER' routine (user can substutute this if necessary / preferred)
;=========================================================================================================================

	; Load in the Speckled files which have been converted to .fits format
start_directory = reduced_dir+filter+'/speckled/'
final_directory = reduced_dir+filter+'/mid_processed/'
files_speckled = FILE_SEARCH(start_directory+'*.fits')

image = READFITS(files_speckled[0],/silent)>0.
image = image / MEDIAN(image)
WRITEFITS,final_directory+'aligned_00000.fits',image

	; Uncomment out if you want to pick a high contrast source for aligning 
;x1 = 535
;x2 = 760
;y1 = 265
;y2 = 435
;temp = FLTARR(x2-x1+1,y2-y1+1,2)
;temp[*,*,0] = image[x1:x2,y1:y2]

	; If using the full FOV make sure you have the right image dimensions for your camera
temp = FLTARR(imagedim[0],imagedim[1],2)
temp[*,*,0] = image
ccshifts = FLTARR(2,2)

xshifts = FLTARR(N_ELEMENTS(files_speckled)-1)
yshifts = FLTARR(N_ELEMENTS(files_speckled)-1)
xshifts[*] = 0.
yshifts[*] = 0.

	; The alignment. This will plot a graph showing the shifts in x and y. 
	; It is here that you choose the alignment procedure (by commenting/uncommenting the relevant method)
mult,1,2
FOR i = 1,(N_ELEMENTS(files_speckled)-1) DO BEGIN &$
    image = READFITS(files_speckled[i],/silent)>0. &$
    image = image / MEDIAN(image) &$
    ;temp[*,*,1] = image[x1:x2,y1:y2] &$
    temp[*,*,1] = image &$
    ccshifts[*] = 0. &$
    FOR j = 0,4 DO ccshifts = ccshifts + TR_GET_DISP(temp,/shift) &$
    ;IF ccshifts[0,1] lt 1. THEN ccshifts[0,1] = 0. &$
    ;IF ccshifts[1,1] lt 1. THEN ccshifts[1,1] = 0. &$
    image = SHIFT(image,ccshifts[0,1],ccshifts[1,1]) &$
    ;image = temp[*,*,1] &$
    xshifts[i-1] = ccshifts[0,1] &$
    yshifts[i-1] = ccshifts[1,1] &$
    ;PUT THE NEXT LINE IN IF YOU WANT CUMULATIVE CO-ALIGNMENT
    ;temp[*,*,0] = image[x1:x2,y1:y2] &$
    ;temp[*,*,0] = image &$
    ;PUT THE NEXT LINE IN IF YOU WANT SEMI-CUMULATIVE CO-ALIGNMENT
    ;IF i MOD 50 EQ 0 THEN temp[*,*,0] = image[x1:x2,y1:y2] &$
    IF i MOD 50 EQ 0 THEN temp[*,*,0] = image &$
    IF (i le 9) THEN name = '0000' + arr2str(i,/trim) &$
    IF (i gt 9) AND (i le 99) THEN name = '000' + arr2str(i,/trim) &$
    IF (i gt 99) AND (i le 999) THEN name = '00' + arr2str(i,/trim) &$
    IF (i gt 999) AND (i le 9999) THEN name = '0' + arr2str(i,/trim) &$
    IF (i gt 9999) AND (i le 99999) THEN name = '' + arr2str(i,/trim) &$
    WRITEFITS,final_directory+'aligned_'+name+'.fits',image &$
    PRINT,'Processing image number ',i,' of ',(N_ELEMENTS(files_speckled)-1) &$
    IF (i MOD 10) eq 0 THEN plot,xshifts,thick=2,xtitle='Frame',ytitle='x Pixel shift',xst=1,yst=1,charsize=2 &$
    IF (i MOD 10) eq 0 THEN plot,yshifts,thick=2,xtitle='Frame',ytitle='y Pixel shift',xst=1,yst=1,charsize=2 &$
ENDFOR
mult,1,1

	; Instigate a test to see the effects of the alignement - take every 10th image
	
test_files = FILE_SEARCH(reduced_dir+filter+'/mid_processed/*.fits')
test_data = FLTARR(imagedim[0],imagedim[1],FIX((N_ELEMENTS(test_files)/10.)))

FOR i = 0, N_ELEMENTS(test_data[0,0,*])-1 DO test_data[*,*,i] = READFITS(test_files[i*10],/SILENT)

xstepper,test_data,xsize=600,ysize=600

	; When happy with the alignment move on to the next step

;=========================================================================================================================
;					DESTRETCH THE ALIGNED IMAGES
;
;	     REQUIREMENTS:	
;		  - You should have a fairly accurately aligned image sequence
;		  - You need to have aome ROSA programs in your idl path
;		  - These can be found in the 'ROSA_pipeline_init.bat' file
;		  - You should have downloaded these with the pipeline
;		  - At the minute, on loading these, some will fail which is okay
;		  - I haven't got round to deleting these now defunct programs
;		  - Will destretch the data to your 'mid_processed' folder
;		  - You may need to change the kernel sizes depending on the data quality
;		  - These must always be sequentially lower [e.g. boxes of 51 -> 31 - > 17..]
;		  - There are some examples included of commonly used values
;		  - After destretching the data then has a slight alignment adjustment again
;		  - At this stage the data is essentially science ready 
;			(unless you plan on comparing to other wavelengths - in which case thereare more alignments)
;=========================================================================================================================

	; Loads in essential programs
	
@ROSA_pipeline_init.bat

	; This should be run from the aligned directory (as it will just write the files 
	;	where you are currently running the code 
	
files = FILE_SEARCH(reduced_dir+filter+'/mid_processed/aligned_*')
temp = READFITS(files[0],/silent)
xsize = N_ELEMENTS(temp[*,0])
ysize = N_ELEMENTS(temp[0,*])

	; You have to select the size of the kernels based on the camera used and data quality
	; This is the sequentially closer boxes over which the destretching is performed
	
;kernels = [51, 31, 17]
kernels = [61, 51, 31]
;kernels = [128, 64, 32, 16]
;kernels = [128, 64, 32]
;kernels = [256, 128, 64, 32]
mask_spacing_x = FIX(DBL(xsize) / kernels[N_ELEMENTS(kernels)-1])
mask_spacing_y = FIX(DBL(ysize) / kernels[N_ELEMENTS(kernels)-1])
disp_mask = BYTARR(mask_spacing_x,mask_spacing_y)
disp_mask[*] = 0

	; You must also choose a threshold mask for destretching
	
lower_threshold_mask = 20 ; given as a percentage of width (GOOD FOR 1004x1002 ROSA IMAGES)
;lower_threshold_mask = 10 ; given as a percentage of width (GOOD FOR 1004x1002 ROSA IMAGES)
;lower_threshold_mask = 8 ; given as a percentage of width (GOOD FOR 2048x2048 sCMOS IMAGES)
lower_mask_x = RND((lower_threshold_mask/100.) * mask_spacing_x)
lower_mask_y = RND((lower_threshold_mask/100.) * mask_spacing_y)
disp_mask[(lower_mask_x-1):(mask_spacing_x-lower_mask_x),(lower_mask_y-1):(mask_spacing_y-lower_mask_y)] = 1 ; THIS IS THE DEFAULT ONE, BUT CAN BE MODIFIED IF NECESSARY!!!
;disp_mask[(lower_mask_x-1):(mask_spacing_x-lower_mask_x),(lower_mask_y-1):(mask_spacing_y-lower_mask_y-1)] = 1 ; GOOD FOR 1004x1002 ROSA IMAGES
;disp_mask[(lower_mask_x-1):(mask_spacing_x-lower_mask_x),(lower_mask_y-2):(mask_spacing_y-lower_mask_y-2)] = 1 ; GOOD FOR 2048x2048 sCMOS IMAGES
	
	; Use this to check the 'disp_mask' is okay
	
temp2 = CONGRID(temp, mask_spacing_x, mask_spacing_y)
contour,disp_mask
tvim,temp2,/noaxis
contour,disp_mask,thick=3,/over
	
	; This now runs the destretching, saves out the destreched images and a save file
	;	with the destretch vectors (in case you need to redo it in future)
	
vectors = ROSA_destretch_noRAM4(files, kernels=kernels, disp_mask=disp_mask, destr_vect_raw=destr_vect_raw,redpath=reduced_dir+filter+'/mid_processed/')
save,FILENAME=reduced_dir+filter+'/calib/destretch_vectors_'+filter+'.sav',vectors,destr_vect_raw


;=========================================================================================================================
;					REMOVE THE RESIDUAL SHIFTS IN THE IMAGES
;
;	     REQUIREMENTS:	
;		  - You should have destretched the data
;		  - This step removes any residual shifts in the camera alignment
;		  - Again, you can choose a high contrast source for the alignment
;		  - Data is effectively science ready after this step
;		  - Additional steps after this though to align cameras w.r.t one another
;		  - Will try to add in the header information here again (to make it SOLARNET compliant)
;=========================================================================================================================


; REMOVE ANY RESIDUAL DRIFTS
files = FILE_SEARCH(reduced_dir+filter+'/mid_processed/destretched_*')
elements = N_ELEMENTS(files)
image = READFITS(files[0],/silent)
xsize = N_ELEMENTS(image[*,0])
ysize = N_ELEMENTS(image[0,*])
temp = FLTARR(N_ELEMENTS(image[*,0]),N_ELEMENTS(image[0,*]),2)

; PICK THE LOCATION IN THE IMAGES WHERE A HIGH-CONTRAST SOURCE IS PRESENT:
; NOTE THESE VALUES FIRST REQUIRE IMAGE ROTATION SO TAKE THAT INTO ACCOUNT!!!!!!
;x1 = 380
;x2 = 615
;y1 = 363
;y2 = 650
;tvim,image,range=[0,6000] & horline,y1 & horline,y2 & verline,x1 & verline,x2
;temp = FLTARR(x2-x1+1,y2-y1+1,2)
;temp[*,*,0] = image[x1:x2,y1:y2]

temp[*,*,0] = image
ccshifts = FLTARR(2,2)
xshifts = FLTARR(N_ELEMENTS(files)-1)
yshifts = FLTARR(N_ELEMENTS(files)-1)
xshifts[*] = 0.
yshifts[*] = 0.
mult,1,2
WRITEFITS,reduced_dir+filter+'/processed/destretched_00000.fits',image
FOR i = 1,(elements-1) DO BEGIN &$
    image = READFITS(files[i],/silent)>0. &$
    ;temp[*,*,1] = image[x1:x2,y1:y2] &$
    temp[*,*,1] = image &$
    ccshifts[*] = 0. &$
    FOR j = 0,4 DO ccshifts = ccshifts + TR_GET_DISP(temp,/shift) &$
    ccshifts = RND(ccshifts) &$
    ;IF ccshifts[0,1] lt 1. THEN ccshifts[0,1] = 0. &$
    ;IF ccshifts[1,1] lt 1. THEN ccshifts[1,1] = 0. &$
    image = SHIFT(image,ccshifts[0,1],ccshifts[1,1]) &$
    ;image = temp[*,*,1] &$
    xshifts[i-1] = ccshifts[0,1] &$
    yshifts[i-1] = ccshifts[1,1] &$	
    ;PUT THE NEXT LINE IN IF YOU WANT SEMI-CUMULATIVE CO-ALIGNMENT
    ;IF i MOD 50 EQ 0 THEN temp[*,*,0] = image[x1:x2,y1:y2] &$
    ;IF i MOD 50 EQ 0 THEN temp[*,*,0] = image &$
    IF (i le 9) THEN name = '0000' + arr2str(i,/trim) &$
    IF (i gt 9) AND (i le 99) THEN name = '000' + arr2str(i,/trim) &$
    IF (i gt 99) AND (i le 999) THEN name = '00' + arr2str(i,/trim) &$
    IF (i gt 999) AND (i le 9999) THEN name = '0' + arr2str(i,/trim) &$
    IF (i gt 9999) AND (i le 99999) THEN name = '' + arr2str(i,/trim) &$
    WRITEFITS,reduced_dir+filter+'/processed/destretched_'+name+'.fits',image &$
    ;IF (i MOD 50) eq 0 THEN temp[*,*,0] = temp[*,*,1] &$
    IF (i MOD 100) eq 0 THEN print,'Processing image '+STRTRIM(i,2)+' of '+STRTRIM(elements,2) &$
    IF (i MOD 100) eq 0 THEN plot,xshifts,thick=2,xtitle='Frame',ytitle='x Pixel shift',xst=1,yst=1,charsize=2 &$
    IF (i MOD 100) eq 0 THEN plot,yshifts,thick=2,xtitle='Frame',ytitle='y Pixel shift',xst=1,yst=1,charsize=2 &$
    IF (i MOD 100) eq 0 THEN wait,0.3 &$
ENDFOR
mult,1,1
	
;***************************************************
	; Alternative approach
;***************************************************
	
; REMOVE ANY RESIDUAL DRIFTS
files = FILE_SEARCH(reduced_dir+filter+'/mid_processed/destretched_*')
elements = N_ELEMENTS(files)
temp = READFITS(files[0],/silent)
xsize = N_ELEMENTS(temp[*,0])
ysize = N_ELEMENTS(temp[0,*])
temp = FLTARR(xsize,ysize,2)
temp[*,*,0] = READFITS(files[0],/silent)
xshifts = FLTARR(elements-1)
yshifts = FLTARR(elements-1)
mult,1,2
WRITEFITS,reduced_dir+filter+'/processed/destretched_00000.fits,REFORM(temp[*,*,0])
FOR i = 1,(elements-1) DO BEGIN &$
    temp[*,*,1] = READFITS(files[i],/silent) &$
    FOR j = 0,4 DO BEGIN &$
        ccshifts = TR_GET_DISP(temp,/shift) &$
	xshifts[i-1] = xshifts[i-1] + ccshifts[0,1] &$
	yshifts[i-1] = yshifts[i-1] + ccshifts[1,1] &$
    ENDFOR &$
    IF (i le 9) THEN name = '0000' + arr2str(i,/trim) &$
    IF (i gt 9) AND (i le 99) THEN name = '000' + arr2str(i,/trim) &$
    IF (i gt 99) AND (i le 999) THEN name = '00' + arr2str(i,/trim) &$
    IF (i gt 999) AND (i le 9999) THEN name = '0' + arr2str(i,/trim) &$
    IF (i gt 9999) AND (i le 99999) THEN name = '' + arr2str(i,/trim) &$	
    WRITEFITS,reduced_dir+filter+'/processed/destretched_'+name+'.fits',REFORM(temp[*,*,1]) &$
    temp[*,*,0] = temp[*,*,1] &$
    IF (i MOD 100) eq 0 THEN print,'Processing image '+STRTRIM(i,2)+' of '+STRTRIM(elements,2) &$
    IF (i MOD 10) eq 0 THEN plot,xshifts,thick=2,xtitle='Frame',ytitle='x Pixel shift',xst=1,yst=1,charsize=2 &$
    IF (i MOD 10) eq 0 THEN plot,yshifts,thick=2,xtitle='Frame',ytitle='y Pixel shift',xst=1,yst=1,charsize=2 &$
ENDFOR
mult,1,1
	
	
	; Instigate a test to see the effects of the alignement - take every 10th image
	
test_files = FILE_SEARCH(reduced_dir+filter+'/processed/*.fits')
test_data = FLTARR(imagedim[0],imagedim[1],FIX((N_ELEMENTS(test_files)/10.)))

FOR i = 0, N_ELEMENTS(test_data[0,0,*])-1 DO test_data[*,*,i] = READFITS(test_files[i*10],/SILENT)

xstepper,test_data,xsize=600,ysize=600

;=========================================================================================================================
;					ADD IN HEADER INFO & CHANGE FILENAMES
;
;	     REQUIREMENTS:	
;		  - Data should be science ready now (by itself)
;		  - Now want to add in the header information if possible
;		  - This should make it SOLARNET compliant
;		  - Want to rename the files based on the time information as well (avoid confusion)
;		  - Therefore require the previous header for use here
;		  - Will also require the data properties
;		  - There is a .bat file called 'ROSA_data_properties.bat' which you need to edit
;		  - This loads in the data properties (e.g. pointing) to put into the header file
;		  - You need the program FIND_POSITION which is in the pipeline path for working out position
;		  - Files are saved as 'ROSA_Filter_YYYYMMDD_HHMMSS.sss.fits' as standard
;
;	** YOU NEED TO EDIT THE FILE @ROSA_data_properties.bat WITH INFORMATION FOR YOUR OBSERVATION CAMPAIGN **
;=========================================================================================================================

@/home/phk/idl/ROSA/ROSA_pipeline_v1.1/ROSA_data_properties.bat

print,ISO_stime									; Check you are using the right data set time
files = FILE_SEARCH(reduced_dir+filter+'/processed/destretched_*.fits')

	; Need to convert the time to the format 'DD-MMM-YYYY HH:MM:SS.s' Where month is letters as opposed to digits
	; Date is needed in this format to calculate the projection of pointing in each frame
	; There is undoubtedly an easier way to do this but I'm sick of looking at random IDL programs which 
	; may or may not be standard, so I'll just do it my way. Start time info is taken from  @ROSA_data_properties.bat

ns_dd = arr2str(dy,/TRIM)							; Start time in the alternative format
IF (DBL(mnth) EQ 1) THEN ns_mmm = 'Jan'						; required by FIND_POSITION
IF (DBL(mnth) EQ 2) THEN ns_mmm = 'Feb'
IF (DBL(mnth) EQ 3) THEN ns_mmm = 'Mar'
IF (DBL(mnth) EQ 4) THEN ns_mmm = 'Apr'
IF (DBL(mnth) EQ 5) THEN ns_mmm = 'May'
IF (DBL(mnth) EQ 6) THEN ns_mmm = 'Jun'
IF (DBL(mnth) EQ 7) THEN ns_mmm = 'Jul'
IF (DBL(mnth) EQ 8) THEN ns_mmm = 'Aug'
IF (DBL(mnth) EQ 9) THEN ns_mmm = 'Sep'
IF (DBL(mnth) EQ 10) THEN ns_mmm = 'Oct'
IF (DBL(mnth) EQ 11) THEN ns_mmm = 'Nov'
IF (DBL(mnth) EQ 12) THEN ns_mmm = 'Dec'
ns_yy = arr2str(yr,/TRIM)
ns_hh = arr2str(hrs,/TRIM)
ns_mm = arr2str(mins,/TRIM)
ns_ss = arr2str(secs,/TRIM)
ISO_stime_alt = ns_dd+'-'+ns_mmm+'-'+ns_yy+' '+ns_hh+':'+ns_mm+':'+ns_ss

FOR i = 0, N_ELEMENTS(files)-1 DO BEGIN &$
	newhead = newheader &$								; Sets the standard values in the header
	image = READFITS(files[i],/SILENT) &$
	TIMESTAMPTOVALUES,ISO_stime,year=yr,month=mnth,day=dy,hour=hrs,minute=mins,second=secs,offset=offset &$

	l = (i * cadence) + (cadence /2.) &$						; [sec] Length of data in seconds (add 1/2 cadence as we can't be sure of the start of the specklegram)
	nhr = FIX(l/(60*60.)) &$							; Number of hours observing
	nms = FIX(((l/(60.)-(nhr * 60.)))) &$  						; Number of mins observing 
	ns = ((((l/(60.)-(nhr * 60.))))-nms)*60. &$					; Number of secs observing
	end_hour = hrs+nhr &$								; End Hour
	end_mins = mins+nms &$								; End Mins
	end_secs = secs+ns &$								; End Secs
	IF (end_secs GE 60) THEN end_mins = end_mins + 1 &$
	IF (end_secs GE 60) THEN end_secs = end_secs - 60 &$				; In case you have more than 60s
	IF (end_mins GE 60) THEN end_hour = end_hour + 1 &$
	IF (end_mins GE 60) THEN end_mins = end_mins - 60 &$				; In case you have more than 60mins
	IF (end_secs GE 10) THEN new_secstr = STRING(end_secs,FORMAT='(F6.3)')	 &$	; Change to string and take 3 d.p.
	IF (end_secs LT 10) THEN new_secstr = '0'+STRING(end_secs,FORMAT='(F5.3)') &$	; If <10 add in a '0' to pad
	new_minstr = arr2str(end_mins,/TRIM) &$						; Change to string 
	IF (end_mins LT 10) THEN new_minstr = '0'+new_minstr &$				; If <10 add in a '0' to pad
	new_hrstr = arr2str(end_hour,/TRIM) &$						; Change to string
	IF (end_hour LT 10) THEN new_hrstr = '0'+new_hrstr &$				; If <10 add in a '0' to pad

	imtime = new_hrstr+new_minstr+new_secstr &$
	
		; Produce a name for the file following suggested convention
	name = 'ROSA_'+filter+'_'+arr2str(yr,/TRIM)+arr2str(mnth,/TRIM)+arr2str(dy,/trim)+'_'+imtime+'.fits' &$
	imrms = SQRT((TOTAL(image^2))/N_ELEMENTS(image)) &$				; Image RMS value

		; Create the time for this particular file in the alt format 
	ISO_etime_alt = ns_dd+'-'+ns_mmm+'-'+ns_yy+' '+new_hrstr+':'+new_minstr+':'+new_secstr  &$ 
	;ISO_etime_wcs = ns_yy+'-'+arr2str(mnth,/trim)+'-'+ns_dd+'T'+new_hrstr+':'+new_minstr+':'+new_secstr+'Z' &$	;Time of this image in WCS standard notation

	pos_out = FIND_POSITION(pointing,ISO_stime_alt,ISO_etime_alt,/OUT_ARCSEC) &$	; Finds the position in this frame
	SXADDPAR,newhead,'HGLT-OBS',pos_out[0],'Stonyhurst heliographic lattitude' &$	; Output Lat/Lon to header  
	SXADDPAR,newhead,'HGLN-OBS',pos_out[1],'Stonyhurst heliographic longitude' &$  
	;SXADDPAR,newhead,'IM_TIME',ISO_etime_wcs,'WCS Time for this particular image' &$
	
	SXADDPAR,newhead,'DATARMS',imrms,'[DN] Root mean square of data' &$  		; Output the RMS to the header
	SXADDPAR,newhead,'DATARMS',imrms,'[DN] Root mean square of data' &$  		; Output the Time stamp to the header
	FITS_ADD_CHECKSUM, newhead,image,/NO_TIMESTAMP &$				; Add Datasum/Checksum to header
	
	SXADDPAR,newhead,'FILENAME',name,' ' &$  					; Output the filename to the header
	time_now = SYSTIME(/UTC) &$							; Date and time of file creation
	SXADDPAR,newhead,'DATE',time_now,'Date of FITS file creation' &$  		; Date of creation added to the header

	WRITEFITS,reduced_dir+filter+'/processed/'+name,image,newhead &$
	print,'Processed filename '+name &$
ENDFOR	

;=========================================================================================================================
;					WORK OUT THE ALIGNMENT VALUES FOR EACH CAMERA
;
;	     REQUIREMENTS:	
;		  - You should have processed all the data for a given pointing ID by this point
;		  - This next stage then aligns the cameras to each other so there is one-to-one correspondence
;		  - First need to load in the Targets/Grids/Dots/Pinholes for each camera
;		  - Also want to save these files out for later use in case they are needed
;		  - You need ROSA_calibration_file_load.bat in the pipeline now
;=========================================================================================================================

;*********************************************************************************
;			     A NOTE ON ALIGNING IMAGES
;
;		Best to discuss this before this section...
;	This is the most tedious part of processing. The aim here 
;	is to get as close an alignment as possible between the various
;	cameras. If you are only looking at ROSA images then it is 
;	customary to choose one of the continuum bands (either Gband 
;	or 4170 - I would personally choose 4170 as it is easier to 
;	align to HMI/AIA data later on if you need to). If you have 
;	IBIS data that you want to align, it is best to do this all 
;	at once aligning the ROSA continuum to the IBIS Whitelight.
;	Then you can work out the values that are needed to get the 
;	other ROSA cameras aligned to the continuum. This process 
;	used to be more user invovled, however, recently a code has 
;	been developed that is more automated in this process. The 
;	old process used the targets to get bulk rotations, the grids
;	gave the scaling of the cameras, the dots gave fine-scale 
;	rotation and the pinholes gave the offsets. With the new 
;	code, you need to sort out the bulk rotations with the targets
;	before passing the corrected dots images into the code for the 
;	cameras you are trying to align. It uses corrmat_analyze.pro 
;	to find the optimal offsets between the corss-correlation of 
;	the two dots images (one must be the continuum image you are 
;	aligning too). The problem with this approach is that it is 
;	computationally intensive. On the QUB cluster this process 
;	usually takes 2 days per filter, so it may not be feasible 
;	on a laptop (equally a better cluster than the QUB one will
;	see this process performed quicker as well). Upon completion 
;	of this proces it is prudent to save the values that you find 
;	for future use, and to apply to the images as a whole to have 
;	a complete science-ready data set.	(P. Keys Dec 2016).
;	 					
;*********************************************************************************
	; First run ROSA_calibration_file_load.bat to load in the Targets/Grids/Dots/Pinholes for each camera
	; The file paths in this directory need to be right or IDL will crash (as it will try to read 
	; files that are not there).
	
@ROSA_calibration_file_load.bat

	; You will now have loaded in the correct images and produced a save file of the 
	; targets/grids/dots/pinholes for each camera. Load them in now again (to be sure)
	
RESTORE,reduced_dir+'Alignment_calibration_images.sav',/ver

	; First you need to make sure that the bulk rotations are fixed
	; Do this by looking at the TARGETS for each
	
mult,2,2
tvim,Gband_calib[*,*,0],title='Gband Targets'
tvim,Cont4170_calib[*,*,0],title='Continuum Targets - Align to'
tvim,CaK_calib[*,*,0],title='Ca K Targets'
tvim,Hbeta_calib[*,*,0],title='Hbeta Targets'
mult,1,1

	; Check the rotation of the filters w.r.t one another
	
mult,2,2
tvim,ROTATE(Gband_calib[*,*,0],0),title='Gband Targets'
tvim,ROTATE(Cont4170_calib[*,*,0],0),title='Continuum Targets - Align to'
tvim,ROTATE(CaK_calib[*,*,0],0),title='Ca K Targets'
tvim,ROTATE(Hbeta_calib[*,*,0],0),title='Hbeta Targets'
mult,1,1

continuum_dots = Cont4170_calib[*,*,0]

	; Apply this value to the dots images prior to running the alignment routine

gband_dots = ROTATE(Gband_calib[*,*,0],0)
cak_dots = ROTATE(CaK_calib[*,*,0],0)
hbeta_dots = ROTATE(Hbeta_calib[*,*,0],0)

	; Work out the alignments for each camera. Use 'demagnification=2' to speed 
	; things up at the expense of the accuracy of the coalignment
	
.r dbj_coalign_images.pro

DBJ_COALIGN_IMGAES,continuum_dots,gband_dots

	; Add the values for the bulk rotation, fine scale rotation, scale and offsets below  
gband_bulk_rotation = 0.
gband_fine_rotation = 
gband_scale = 
gband_offsets = [,]

;DBJ_COALIGN_IMGAES,continuum_dots,cak_dots
cak_bulk_rotation = 0.
cak_fine_rotation = 
cak_scale = 
cak_offsets = [,]

;DBJ_COALIGN_IMGAES,continuum_dots,hbeta_dots
hbeta_bulk_rotation = 0.
hbeta_fine_rotation = 
hbeta_scale = 
hbeta_offsets = [,]

	; Save these out as string arrays for future use

Gband_camera_alignment = STRARR(5)
Gband_camera_alignment[0] = 'Bulk rotation of camera = '+arr2str(gband_bulk_rotation,/trim)
Gband_camera_alignment[1] = 'Fine-scale rotation of camera = '+arr2str(gband_fine_rotation,/trim)
Gband_camera_alignment[2] = 'Relative scale of camera = '+arr2str(gband_scale,/trim)
Gband_camera_alignment[3] = 'Offset in x of camera = '+arr2str(gband_offsets[0],/trim)
Gband_camera_alignment[4] = 'Off set in y of camera = '+arr2str(gband_offsets[1],/trim)

CaK_camera_alignment = STRARR(5)
CaK_camera_alignment[0] = 'Bulk rotation of camera = '+arr2str(cak_bulk_rotation,/trim)
CaK_camera_alignment[1] = 'Fine-scale rotation of camera = '+arr2str(cak_fine_rotation,/trim)
CaK_camera_alignment[2] = 'Relative scale of camera = '+arr2str(cak_scale,/trim)
CaK_camera_alignment[3] = 'Offset in x of camera = '+arr2str(cak_offsets[0],/trim)
CaK_camera_alignment[4] = 'Off set in y of camera = '+arr2str(cak_offsets[1],/trim)

Hbeta_camera_alignment = STRARR(5)
Hbeta_camera_alignment[0] = 'Bulk rotation of camera = '+arr2str(hbeta_bulk_rotation,/trim)
Hbeta_camera_alignment[1] = 'Fine-scale rotation of camera = '+arr2str(hbeta_fine_rotation,/trim)
Hbeta_camera_alignment[2] = 'Relative scale of camera = '+arr2str(hbeta_scale,/trim)
Hbeta_camera_alignment[3] = 'Offset in x of camera = '+arr2str(hbeta_offsets[0],/trim)
Hbeta_camera_alignment[4] = 'Off set in y of camera = '+arr2str(hbeta_offsets[1],/trim)

SAVE,FILENAME=reduced_dir+'Camera_coalignment_calibration_info.sav',Gband_camera_alignment,CaK_camera_alignment,Hbeta_camera_alignment

;=========================================================================================================================
;					APPLY ALIGNMENT VALUES TO THE DATA
;
;	     REQUIREMENTS:	
;		  - You should have processed all the data for a given pointing ID 
;		  - You should have established the coalignment values (rotation, scale, offset)
;=========================================================================================================================

	; Load in the filters etc again to make it easier
filter = 'Gband'
;filter = 'Continuum4170'
;filter = 'CaK'
;filter = 'Hbeta'

	; Input the image dimensions of the camera you are processing 
	; and more general variable names for the calibration values
	; This  makes it easier to augment for various filters 
imagedim = [1004,1002]
;imagedim = [512,512]

flip = gband_bulk_rotation			; Bulk Rotation (from targets)
rotation_num = gband_fine_rotation		; Fine scale rotation 
scale_factor = gband_scale
offset = gband_offsets

	; Load in the images and apply the shifts etc that are required to align them

files = FILE_SEARCH(reduced_dir+filter+'/processed/ROSA_*.fits')

FOR i = 0, N_ELEMENTS(files)-1 DO BEGIN &$
	image = READFITS(files[i],header,/SILENT) &$
	image_n = ROT(CONGRID(ROTATE(image,flip),imagedim[0],imagedim[1]),rotation_num,scale_factor,((imagedim[0]/2.)-offset[0]),((imagedim[1]/2.)-offset[1])) &$
    	WRITEFITS,files[i],image_n,header &$
ENDFOR
	; ** Note ** that at this stage, we are effectively updating the files from before that were SOLARNET compliant
	; I would keep the 'destretched_*' FITS files in the processed file up to now in case there is some issue in 
	; applying these calibration values to the images (e.g. wrong values applied or computer attains sentience..)
	; Therefore, the datasum, checksum and date on the 'Simple' keywords will all be updated when perfomring this 
	; step. I have refrained from updating the 'DATE' keyword in this new header as it could be useful in the future 
	; to know when the data was essentially fully processed (i.e. all but alignments performed). This date is likely 
	; to be different as it is better to have all the data processed before working out and applying this final 
	; calibration of the data. Also, be aware that the value for the pointing is taken directly from the telescope 
	; during operation. Therefore, this may not be 100% accurate when looking at the data later (due to shifts thanks 
	; to offsets and the fact that we have assumed that the continuum is the correct value). This should be a good 
	; benchmark though. To get really accurate values you will need to align the images to HMI and use 
	; cross-correlation techniques to get sub-pixel alignment. Then the HMI data will give you the super-accurate 
	; pointing for your data set. 

;=========================================================================================================================
;				GENERATE SAMPLE IMAGES OF ALL FILTERS REDUCED FOR THIS DATA SET
;
;	     REQUIREMENTS:	
;		  - Fully processed data set across all filters
;		  - This effectively generates a nice thumbnail of the data
;		  - Used to give people an idea of quality
;		  - A reminder for future use of the pointing of the data
;=========================================================================================================================

	; Load in the files for each filter	
Gb = FILE_SEARCH(reduced_dir+'Gband/processed/ROSA*')
Ct = FILE_SEARCH(reduced_dir+'Continuum4170/processed/ROSA*')
Ck = FILE_SEARCH(reduced_dir+'CaK/processed/ROSA*')
Hb = FILE_SEARCH(reduced_dir+'Hbeta/processed/ROSA*')

Gband_im = READFITS(gb[0],/SILENT)
Cont_im = READFITS(ct[0],/SILENT)
CaK_im = READFITS(ck[0],/SILENT)
Hbeta_im = READFITS(hb[0],/SILENT)

!p.background = 255.
!p.color=0.

	; Plot the images
WINDOW,0,xsize=1000,ysize=1000
mult,2,2
tvim,Gband_im,title='Gband',pcharsize=1.8
tvim,Cont_im,title='Continuum4170',pcharsize=1.8
tvim,CaK_im,title='CaK',pcharsize=1.8
tvim,Hbeta_im,title='Hbeta',pcharsize=1.8
mult,1,1

	; Have to change the 'Start time' naming structure as copying to FTP site doesn't like 
	; the other variatio (YYYY-MM-DD due to the '-'s present I think. Therefore change to 
	; DDMMYYYY_HHMMUT_Sequence_sample_images.jpg
im_start_time = ns_dd+ns_mmm+ns_yy+'_'+ns_hh+ns_mm+'UT'
	
	; Save images out
X2JPEG,reduced_dir+im_start_time+'_Sequence_sample_images.jpg'
;=========================================================================================================================
;
;	For all intents and purposes, you are now finished processing.
;
;	I may augment this file in the future to ensure that it has less input from pipeline users 
;	For the moment though, this pipeline should satisfy the requirements of most researchers
;
;	** REMEMBER ** At this point you may want to delete the excess files in the /Raw/ and the 
;	/speckled/ and /mid_processed/ paths. Be careful that you are 100% certain that you want 
;	to hit delete before you do that. These mid-level files take up space though.
;
;	** QUB USERS ** For QUB users, you should now move the files to /data/solarstore1/. Also 
;	update our wiki page (the reconstructed archive page) so that we have an up-to-date database 
;	of all the data on solarstore1 (as I don't know what you did to your data and don't want to 
;	have to go through it all to check). For simplicity the archive is found here:
; 
;	https://star.pst.qub.ac.uk/wiki/doku.php/public/research_areas/solar_physics/rosa_reconstructed_archive        
;
;	If needs be copy to FTP site at QUB:
;	scp -r FOLDER phk@star.pst.qub.ac.uk:/misc/ftp/pub/phk/SOLARNET_2016/PATH/
;=========================================================================================================================
							END
